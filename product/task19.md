# User Story: Google Calendar Event Sync During Schedule Autogeneration

## Story
**As a** user with Google Calendar integration  
**I want** my calendar events to be automatically included when my daily schedule is generated  
**So that** I have a complete view of all my tasks and calendar commitments in one place

## Background
The autogeneration feature currently creates daily schedules by filtering incomplete tasks and recurring tasks. Users with Google Calendar integration need their calendar events included to have a complete daily view without manual synchronization.

## Acceptance Criteria

### 1. Calendar Integration Detection
- **GIVEN** I am a logged-in user
- **WHEN** the autogenerate function is triggered
- **THEN** the system checks if `user.calendar.connected === true` or `user.calendarSynced === true`
- **AND** only proceeds with calendar sync if integration exists

### 2. Calendar Event Fetching
- **GIVEN** I have Google Calendar integrated
- **WHEN** autogeneration is triggered for a specific date
- **THEN** the system fetches calendar events for that date (max 10 events)
- **AND** selects the earliest 10 by start time in the user's timezone (tie-break alphabetically by title)
- **AND** includes all-day and multi-day events that overlap the target date
- **AND** uses the user's primary calendar from `user.calendar` settings

### 3. Parallel Execution
- **GIVEN** autogeneration is running
- **WHEN** processing tasks and calendar events
- **THEN** the system executes with backend-managed concurrency:
  - ✅ **Chosen: Option A** — Backend runs task filtering/recurrence and calendar fetch concurrently within `/api/schedules/autogenerate`
  - (Not used) Option B: Frontend makes parallel API calls to autogenerate and calendar endpoints, then merges results
- **AND** maintains the 10-second maximum loading time using a server-side sub-timeout (~8s) for calendar fetch; on timeout, proceed without calendar

### 4. Event Positioning
- **GIVEN** calendar events are fetched successfully
- **WHEN** merging with autogenerated tasks
- **THEN** calendar events are inserted as a single contiguous block:
  - Immediately after the first section if sections exist (associate each event's `section` to the first section's value)
  - At the top of the list if no sections exist
- **AND** events within the block maintain chronological order (in user timezone), with all-day events first

### 5. Event Deduplication
- **GIVEN** the source schedule may contain old calendar events
- **WHEN** processing calendar events
- **THEN** the system:
  - Excludes completed calendar events from source schedule
  - Includes only incomplete calendar events from source
  - Adds new calendar events for the target date
  - Uses `gcal_event_id` for per-date deduplication (primary key)
  - Keeps `from_gcal: true` for compatibility (may deprecate later)

### 6. Multi-day Event Handling
- **GIVEN** a calendar event spans multiple days
- **WHEN** fetching events for a specific date
- **THEN** include the event only if it occurs on the target date
- **AND** ensure no duplication using unique identifiers

### 7. Failure Handling
- **GIVEN** calendar fetch may fail
- **WHEN** calendar API returns an error
- **THEN** the autogeneration continues without calendar events
- **AND** returns the schedule with tasks only (no blocking)
- **AND** if the calendar sub-operation times out server-side, proceed without calendar

### 8. Token Refresh
- **GIVEN** Google Calendar access token may expire
- **WHEN** calendar fetch receives authentication error
- **THEN** attempt to refresh the token using refresh token (reuse existing token refresh logic)
- **AND** proceed with fetch if refresh succeeds, skip if fails

### 9. Create Next Day Integration
- **GIVEN** the "Create Next Day" functionality exists
- **WHEN** generating tomorrow's schedule (via the same `/api/schedules/autogenerate`)
- **THEN** fetch tomorrow's calendar events
- **AND** merge with filtered tasks from today's schedule
- **AND** carry over incomplete Google Calendar tasks from today's schedule to tomorrow, keeping their `start_time`/`end_time` and setting `start_date` to tomorrow (dedup by `gcal_event_id` against fetched events)

## Technical Implementation Notes

### Frontend (React/TypeScript)
- Maintain single skeleton loader (max 10s) regardless of parallel operations
- No merge logic needed on FE (Option B not used); continue to call `/api/schedules/autogenerate`
- Pass correct date parameter for both today and tomorrow scenarios

### Backend (Python/Flask)
- Extend `/api/schedules/autogenerate` to include calendar fetching and merging (Option A)
- Check user's calendar integration status from user object
- Run task carryover/recurrence and calendar fetch in parallel with a sub-timeout (~8s)
- Fetch max 10 events per day from primary calendar, sorted by start time in user timezone (all-day first)
- Include all-day/multi-day events; convert to Task objects with `gcal_event_id` and `from_gcal: true`
- Insert events as a contiguous block (after first section or top), setting `section` when applicable
- Deduplicate per-date by `gcal_event_id` (merge carried-over incomplete gcal tasks + fetched events)
- Reuse existing token refresh logic on auth failure and persist refreshed tokens
- Proceed without calendar if fetch/refresh fails or times out
- Keep `metadata.source = 'manual'`; set counts accordingly; SSE unchanged

### Database
- No schema changes required
- Calendar events stored as regular tasks with additional identifiers
- Utilize existing task structure with calendar-specific fields

## Definition of Done
- [ ] Calendar integration check implemented
- [ ] Calendar events fetched for target date (today/tomorrow)
- [ ] Events positioned correctly (below first section or at top)
- [ ] Deduplication logic prevents duplicate calendar entries
- [ ] Multi-day events handled correctly
- [ ] Failure doesn't block autogeneration
- [ ] Token refresh attempted on auth failure
- [ ] 10-second timeout maintained (server-side calendar sub-timeout in place)
- [ ] Manual testing confirms all scenarios work

## Edge Cases Handled
- No calendar integration: skip calendar sync entirely
- Expired tokens: attempt refresh, continue without calendar if fails
- Calendar API failure: return schedule without events
- Maximum 10 events limit enforced (earliest by start time; tie-break alphabetical)
- Multi-day events included only for relevant dates
- Duplicate prevention using unique identifiers
- Empty calendar: proceed with task-only schedule

## Implementation Decision Points (Resolved)
1. **Parallel Execution Architecture**
   - ✅ Option A: Backend handles both operations concurrently in single endpoint
   - ❌ Option B: Frontend makes parallel calls and merges results
2. **Unique Identifier for Deduplication**
   - ✅ Use `gcal_event_id` for lookup and per-date deduplication
   - Keep `from_gcal: true` temporarily for compatibility (consider deprecation later)
3. **Ordering Details**
   - Sort by start time in user timezone; tie-break alphabetically by title
   - Treat all-day events as earliest within the day

## Dependencies
- Existing Google Calendar integration (`calendar_routes.py`, `calendar.ts`)
- User object with calendar connection status
- Calendar API credentials and refresh token mechanism
- Existing autogenerate endpoint and logic

## Out of Scope
- Calendar event caching (MVP skips this)
- Multiple calendar support (only primary calendar)
- Calendar sync toggle (always enabled if integrated)
- Manual sync button (removed as per previous story)
- Event filtering or preferences